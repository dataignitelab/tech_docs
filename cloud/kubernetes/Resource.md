# 리소스 종류

쿠버네티스에서는 모든 것을 ‘Resource’ 라는 단위로 관리하고 실행한다. 따라서 리소스의 존재 여부를 알아야지만 목적에 알맞게 쿠버네티스를 사용할 수 있을 것이다.

### *Pod*

- 컨테이너를 실행하는 기본단위다.
- Pod는 하나 또는 여러개의 컨테이너로 구성될 수 있으며, 같은 Pod 에 있는 컨테이너끼리는 같은 머신에서 실행하는 것처럼 localhost 로 통신이 가능하다.

### RelicaSet

- Pod 의 안정적인 서비스를 위하여 이중화 해야할 경우 복제본을 자동생성 해서 운영이 가능하도록하는 리소스다. 몇개의 복제본을 운영할 것인지 지정하면 알아서 여러개 만들어서 운영됨.
- RelicaSet 자체에서는 접속에 대한 로드밸런싱 기능이 없기 때문에 서비스의 접속을 담당하는 Service 리소스와 연계하여 사용해야 로드밸런싱까지 가능함.

### *Deployment*

- RelicaSet 에서 확장된 개념으로 RelicaSet 을 직접 사용하는 것은 권장하지 않는다고 한다. RelicaSet 의 주된 기능인 복제본 생성 기능에 더하여 Pod 의 버전 업데이트 및 롤백 등에 대한 배포 관리 기능이 추가되어있다.
- 다시 말해서 서비스 운영할일 있으면 RelicaSet 쓰지말고 그냥 Deployment 써라. Pod 한개만 운영하더라도 그냥 Deployment 써라.

### *DaemonSet*

- 모든 노드 또는 지정한 노드들에 Pod 가 반드시 한개 이상씩 실행되는 구조 리소스. 특정한 목적을 가지고 실행되는 것이 일반적으로 클러스터의 노드들의 스토리지와 관련된 서비스나 로그 수집, 노드 모니터링 등과 같은 목적을 위해서 사용된다.
- 빅데이터 플랫폼 분야에서 보자면, 모든 노드에서 실행되어서 각 노드에 자원을 모두 활용하는 분산처리 기능을 수행하는 Spark, Hadoop 과 같은 것들은 반드시 DaemonSet 으로 활용해야 한다.

### StatefulSet

- 상태 유지가 필요한 Pod 를 운영할 때 사용하는 리소스이다. 기존 Deployment 나 RelicaSet 은 상태 유지가 안된다는 특징이 있다. 다시 말해 Pod가 종료되면 아예 새로운 이름의 Pod로 대체된다는 것이다. 또한 스토리지도 모든 Pod 가 하나를 공유하게 된다. StatefulSet 은 이와 다르게 각 Pod 는 항상 동일한 이름을 갖게 되며 각 Pod 마다 각기 다른 스토리지를 갖게하는 리소스이다.
- 활용 예로 들자면 DB 서버처럼 항상 동일한 저장소와 세팅으로 유지되어야하는 서버들이 있겠다.

### Service

- Pod 를 IP와 Port 로 접근해서 사용하고자 할때 사용되는 리소스이다. 쿠버네티스는 Pod 를 띄우면 적정한 노드에 내부에서 관리하는 IP로 자동할당하게 실행하게 되는데, 이에 대한 상세한 정보 없이도 접속 가능하도록 하게하는 것이다. Service 에 사용자가 해당 Pod에 접근할 때 사용할 아이피와 포트 번호를 할당하고 해당 Service 와 Pod 를 연결하면 된다.
- 물론 완전 자유롭게 설정 가능한 것은 아니고 설정에 따라 가능한 범위가 있기 때문에 서비스에 따라 적절한 서비스 유형을 선택해야한다. 서비스 유형에는 ClusterIP, NodePort, LoadBalancer, ExternalName 이 있다.
    - ClusterIP : 기본적인 Service로 클러스터 내부에서 파드끼리 통신할때 사용한다.
    - NodePort : 서비스를 외부로 노출할 때, 클러스터 노드들의 IP 를 사용하되 포트만 포트포워딩 걸어서 외부로 서비스를 노출할 수 있다. 특정 노드 상관없이 클러스터 내의 모든 노드의 아이피로 접근 가능하다. 한가지 제약사항으로는 포트는 3000 ~ 32767 범위만 사용가능하다.
    - LoadBalancer : 외부로 서비스를 노출할 때 사용하는 대표적인 방식이라고 할 수 있다. 다수 IP 풀을 관리할수도 있으며 이름처럼 L4 스위치 역할을 수행한다.
    - ExternalName : 도메인이름으로 접근하는 서비스이다. 클러스터 DNS 를 활용한다.
- 위에서도 언급 했듯이 Deployment, RelicaSet 에서 복제본을 운영할때 L4 스위치 역할을 수행하게 된다. 접속에 대한 설정을 어떻게 관리할 것인가에 대한 설정도 별도로 존재한다.

### EndPoints

- IP 를 담당하는 하는 리소스다. Service 를 선언하면 내부적으로 EndPoints를 생성해서 매핑해준다. 참고로 Service와 Pod 는 Label 로 매핑된다. 디테일하게 쿠버네티스의 서비스를 설정하고자 한다면 건드리겠지만 일반적으로 쓸일은 많지 않다.

### Ingress

- Service가 L4 스위치라면, Ingress는 L7 스위치다. 서비스 URL과 Path, QueryString 단위로 연결할 Service 를 지정하는 것이 가능하다.
- 쿠버네티스에서 마이크로 서비스를 운영할 수 있게하는 핵심 리소스 중 하나이다.

### ConfigMap

- 쿠버네티스에서 관리할 실행 변수들을 저장하는 Key/Value 형태의 저장소이다. 여기서 실행 변수라 함은 개발/배포 모드에 따른 스위칭값, 서버의 환경설정 파일 등이 있다.
- 값은 Pod 의 환경변수로 넘길수도 있고 Volume 으로 마운트해서 파일로 이용도 가능하다

### Secret

- ConfigMap 의 보안강화버전이다. 패스워드나 api key 같은걸 저장할 때 쓰면 된다.
- 사용법은 ConfigMap 과 동일하나 값을 저장할때 반드시 base64로 변환해서 저장해야한다. 이유는 ConfigMap에서는 저장하지 않는 “보안 인증서”와 같은 바이너리파일의 값을 문자열타입으로 저장하기 위해서이며, 실제 활용될때는 자동으로 디코딩되어 원래 값이 사용된다.

### Label

- Pod를 관리하기 위한 논리적 단위다. 마이크로서비스 관점에서 하나의 서비스가 여러개의 Pod 로 구성되어 운영됨으로써 Pod 들을 그룹핑할 수 있는 논리적인 수단이 필요하게 되었고 쿠버네티스에서는 이를 Label 로서 관리한다. 하나의 Pod는 여러개의 Label 을 가질수 있으므로 필요에 따라 세분화하여 지정하면 되겠다.
- 다양한 조건을 걸어서 특정 Label 을 가진 Pod 들을 검색하는 것이 가능하다.

### Annotation

- Label 과 비슷하지만 Pod 에 대한 메타정보(버전, 작성자, 날짜 등등)를 명시 목적으로 활용된다. 그리고 이 메타정보는 Pod 간 연동시 해당 시스템들에게 참고하여 활용하게 된다.

### Namespace

- 쿠버네티스에서는 다양한 목적의 서비스들이 올라가는 만큼 해당 서비스를 구분할 수 있는 논리적 개념의 큰 그룹화가 필요한데, 이를 담당하는 것이 Namespace다.
- Project 개념이라고 볼 수 있으며, 리소스 간의 연동시 같은 Namespace 안에 있는 것을 참조하는 것이 원칙이다.

### PersistentVolume (PV)

- Pod 에서 구동중인 서비스의 데이터를 영구적으로 저장할 필요가 있을때 활용되는 것이 PersistentVolume 이다. 어디에 얼마만큼 읽기/쓰기 권한은 어떠한지 지정하여 생성한다. 즉 스토리지 자원 자체를 쿠버네티스에서 관리하겠다는 걸로 보면 되겠다.
- PersistentVolume 은 로컬 디스크와 NFS, 각종 클라우드 스토리지 들을 지원한다.

### PersistentVolumeClaim (PVC)

- Pod 에서 PersistentVolume(이하 PV)을 직접적으로 연결해서 사용하지 않고 중간에 PersistentVolumeClaim(이하 PVC) 이라는 중개자를 통해서 활용하게 된다.
- PV 를 서버 스토리지를 관리하는 인프라 담당자가 미리 만들어 두면, Application 개발자가 자신의 서비스에서 필요한 조건(스토리지 타입, 용량, 읽기쓰기 권한등)들을 명시한 PVC를 만들고 이를 통하여 스토리지를 요청하고 할당 받는다.
- 만약 PVC 조건의 맞는 PV가 없다면, 해당 Pod 는 볼륨을 할당받지 못하여 실행되지 않을 것이다.
- PVC 이 삭제될 때 PV의 파일들에 대한 삭제 여부에 대해서 설정 가능하다.

### StorageClass

- PersistentVolume은 미리 만들어 두는 개념이다. 하지만 항상 미리 만들어 둘수는 없지 않은가? PersistentVolumeClaim의 요청이 있을때 마다 자동 생성 싶다고 한다면, StorageClass 를 사용하면 된다. PersistentVolumeClaim에서 어떤 StorageClass 를 사용할 것인지 지정하면, StorageClass에 명시된 조건대로 PersistentVolume이 생성되어 할당된다. 이를 Dynamic Provisioning 이라고 한다.
- 모든 유형의 스토리지를 기본 지원하는 것이 아니므로 필요에 따라 별도의 플러그인 개념의 Provisioner(Pod)를 쿠버네티스 API Server에 등록하여 PVC의 요청이 있을 때마다 해당 Provisioner가 PersistentVolume을 생성하는 형태로 구성된다. 물론 이미 다른 사람들이 다양한 유형의 Provisioner 들을 잘 만들어 두었으므로 이를 가져다가 활용하면 되겠다.

### ServiceAccount

- 쿠버네티스 인증 방식은 크게 사용자 인증(ID/PW) 방식과 ServiceAccount 방식이 있다. 사용자 인증방식은 말그대로 사용자가 로그인에서 쿠버네티스를 직접 사용하는 것이다. 하지만 운영하다보면 사용자가 쓰는게 아니라 Pod가 쿠버네티스에 직접 요청해서 사용할일 있지 않을까해서 만들어둔것이 ServiceAccount 다. 접근 및 사용 범위에 따라 다양한 권한설정이 가능하다.
- 예를 들자면 StorageClass 에서의 Provisioner를 언급할 때 Pod인 Provisioner가 PersistentVolume를 생성한다고 했다. 여기서 Provisioner가 쿠버네티스에게 명령을 내리기 위한 ServiceAccount 를 할당 받게 된다.

# 마무리

일단 생각나는대로 리소스들을 적어보았는데, 나중에 빠진게 있다싶으면 추가로 넣어 두겠다.
